\section{Implementation}
\subsection{Hostnavn}
Ved opstart af bosh bliver computerens hostname fundet. Hostname kan findes i en fil på \texttt{/proc} filsystemet som har fil-addressen \texttt{/proc/kernel/hostname}. Denne fil, som generes af operativsystemet, indeholder en linje som er computerens hostname.

Derfor kan vi for at få fat i hostname, bare læse den første linje i denne fil, og derefter lukke den igen.

Dette er gjort med systemkaldene \texttt{fopen}, \texttt{fclose} og \texttt{fscanf}. Alle disse systemkald findes i headerfilen \texttt{stdlib.h}.

\texttt{fopen} tager imod to argumenter, en filsti og en adgangstilladelse til enten at skrive eller læse. Da vi i BOSH kun skal læse fra filen beder vi kun om læsetilladelsen ved at give karakteren \texttt{r} som adgangstilladelse. Det betyder at vi kun kan læse fra filen. Når funktionen returnerer får vi en værdi tilbage af typen \texttt{FILE}, som kan bruges til at referere til filen.

\texttt{fscanf} tager så imod denne FILE, og derudover et format der skal læses, og til sidst, den (eller de) variable eller felter der skal læses til. Vi læser hele filen med formatet \texttt{\%s}, og vi læser hele resultatet ind i hukommelsen, begyndende derfra hvor \texttt{hostname} peger.

\subsection{Enkeltstående kommandoer}
BOSC skal ikke reimplementere operativ programmer men derimod kalde starte dem. Dette gøres ved at forke shellen process ud i to processor ved hjælp af systemkaldet \verb+fork()+. Børne processen kan derefter ved hjælp af systemkaldet \verb+execvp()+ starte programmer der ligger i Path i operativsystemet. 

Den udleverede \verb+parser.h+ opsplitter automatisk brugerens input i kommandoer og parametre. Derfor kan BOSC videreføre augumenter til \verb+execvp+ således at programmet udføres som forventet.
\subsection{Baggrundsprocesser}
En proces kan startes i baggrunden i BOSC. Dette indebærer at BOSC starter processen, og ikke venter på at processen bliver færdig med eksekvering. 

Kontrollen gives tilbage til BOSC, og brugeren kan herefter evt. indtaste en ny kommando til eksekvering. 

Dette er helt konkret implementeret vha. systemkaldene \verb+execvp()+ og \verb+fork()+. Brugerens kommando bliver trukket ud af \verb+parser.c+'s resultat, og gives som parameter til \verb+execvp()+ sammen med eventuelle tilhørende argumenter. 

Der oprettes en børne-proces når brugeren indtaster en kommando. Denne kommando står for eksekvering af den ønskede kommande vha. \verb+execvp()+. 

Hvis brugeren har tastet \verb+&+, er den bolske værdi \verb+background+ i \verb+parser.c+'s resultat sat til true. 

Det tjekkes i \verb+bosh.c+ hvorvidt værdien er \verb+true+, og hvis dette er tilfældet, returnerer \verb+executeshellcmd+. Hvis ikke anvendes systemkaldet \verb+waitpid()+, og forældreprocessen venter på børneprocessens eksekvering. Herefter returneres.
\subsection{Redirection til og fra filer}
For at 
\subsection{Pipes}
\subsection{Afslutning}

\subsection{Luk kommandoer, men ikke BOSH}
For at gøre det muligt at CTRL+C'e sig ud af et givent kørende program anvendes \verb+signal()+ systemkaldet. Ved at kalde \verb+signal(SIGINT, SIG_DFL)+ når en børneproces startes i \verb+start_child()+-funktionen, sættes SIGINT (der sender \verb+interrupt+ til processen) tilbage til standard-opførsel.

Dette er nødvendigt da der i \verb+main()+-funktionen (som vi har fået udleveret) er kaldt \verb+signal(SIGINT, SIG_IGN)+, der beder processen (dvs. forældreprocessen) ignorere \verb+interrupt+, da det er ønsket kun at kunne afbryde brugerens kaldte processer. BOSH selv skal ikke afbryde.  