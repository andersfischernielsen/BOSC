\section{Implementation}
\subsection{Hostnavn}
Ved opstart af bosh bliver computerens hostname fundet. Hostname kan findes i en fil på \texttt{/proc} filsystemet som har fil-addressen \texttt{/proc/kernel/hostname}. Denne fil, som generes af operativsystemet, indeholder en linje som er computerens hostname.

Derfor kan vi for at få fat i hostname, bare læse den første linje i denne fil, og derefter lukke den igen.

Dette er gjort med systemkaldene \texttt{fopen}, \texttt{fclose} og \texttt{fscanf}. Alle disse systemkald findes i headerfilen \texttt{stdlib.h}.

\texttt{fopen} tager imod to argumenter, en filsti og en adgangstilladelse til enten at skrive eller læse. Da vi i BOSH kun skal læse fra filen beder vi kun om læsetilladelsen ved at give karakteren \texttt{r} som adgangstilladelse. Det betyder at vi kun kan læse fra filen. Når funktionen returnerer får vi en værdi tilbage af typen \texttt{FILE}, som kan bruges til at referere til filen.

\texttt{fscanf} tager så imod denne FILE, og derudover et format der skal læses, og til sidst, den (eller de) variable eller felter der skal læses til. Vi læser hele filen med formatet \texttt{\%s}, og vi læser hele resultatet ind i hukommelsen, begyndende derfra hvor \texttt{hostname} peger.

\texttt{fclose} lukker den \texttt{FILE} man giver den som argument.

\subsubsection{Mulige problemer}
Da \texttt{fscanf} ikke tager imod en maxlængde af \texttt{hostname} forestiller vi os at vores nuværende implementation af BOSH kan få problemer i tilfælde af at computeren der kører koden har et hostname der er længere end 100 karakterer, da det er den mængde hukommelse der tildeles feltet \texttt{hostname}.

\subsection{Enkeltstående kommandoer}
BOSH skal ikke reimplementere operativ programmer men derimod kalde starte dem. Dette gøres ved at forke shellen process ud i to processor ved hjælp af systemkaldet \verb+fork()+. Børne processen kan derefter ved hjælp af systemkaldet \verb+execvp()+ starte programmer der ligger i Path i operativsystemet. 

Den udleverede \verb+parser.h+ opsplitter automatisk brugerens input i kommandoer og parametre. Derfor kan BOSH videreføre augumenter til \verb+execvp+ således at programmet udføres som forventet.
\subsection{Baggrundsprocesser}
En proces kan startes i baggrunden i BOSH. Dette indebærer at BOSH starter processen, og ikke venter på at processen bliver færdig med eksekvering. 

Kontrollen gives tilbage til BOSH, og brugeren kan herefter evt. indtaste en ny kommando til eksekvering. 

Dette er helt konkret implementeret vha. systemkaldene \verb+execvp()+ og \verb+fork()+. Brugerens kommando bliver trukket ud af \verb+parser.c+'s resultat, og gives som parameter til \verb+execvp()+ sammen med eventuelle tilhørende argumenter. 

Der oprettes en børne-proces når brugeren indtaster en kommando. Denne kommando står for eksekvering af den ønskede kommande vha. \verb+execvp()+. 

Hvis brugeren har tastet \verb+&+, er den bolske værdi \verb+background+ i \verb+parser.c+'s resultat sat til true. 

Det tjekkes i \verb+bosh.c+ hvorvidt værdien er \verb+true+, og hvis dette er tilfældet, returnerer \verb+executeshellcmd+. Hvis ikke anvendes systemkaldet \verb+waitpid()+, og forældreprocessen venter på børneprocessens eksekvering. Herefter returneres.
\subsection{Pipes og redirection til og fra filer}
En process in og out kan sættes ved hjælp af \verb+dup()+ eller \verb+dup2()+ systemkaldene. Disse tager et programs standard in og out og sætter dem til den en og out som sættes i parametrene. En pipe tillader to processer at kommunikere ved at sætte den ene process' out til pipens out og den anden process' in til pipens in.

I BOSH skal vi håndterer både redirects og og pipes. Tilsammen er der 9 forskellige cases.
\begin{enumerate}
	\item Enkeltstående kommando har redirect in og out.
	\item Enkeltstående kommando har redirect in.
	\item Første kommando, men ikke sidste, har redirect in, og skal skrive til en ny pipe.
	\item Eneste kommando har redirect out.
	\item Sidste, men ikke første, kommando har redirect out og skal læse fra pipen.
	\item Enkeltstående kommando har ingen redirects.
	\item Første, men ikke sidste, kommando skal skrive til en ny pipe.
	\item Sidste kommando, men ikke første, uden redirect men skal læse fra pipe.
	\item Mellemstående kommando, skal læse fra pipe og skrive til en ny pipe.
\end{enumerate}

Disse cases er håndteret i funktionen \verb+set_in_out()+, dog er der lavet nogle optimeringer som gør at hvert case ikke er direkte repræsenteret med if statements men at de bliver dækket af hinanden, fx. er case 4 og 5 dækket af samme branch fordi argumentet \texttt{pipe\_in} bliver sat til henholdsvis standard in eller den tidligere pipes in.

Funktionen \texttt{set\_in\_out()} tager desuden imod en række argumenter, hvor de sidste to er resultaterne af metoden. Disse to argumenter er \textit{pointers} til hukommelses områder der indeholder integers. Når funktionen returnerer er begge disse hukommelsesområder sat til de tal der repræsenterer henholdsvis ind- og ud-fildeskriptorerne. Disse deskriptorer håndteres af operativsystemet, på en sådan måde, at man ikke kan se forskel på pipes og egentlige filer. På den måde har vi kunne spare en del kode i \texttt{start\_child()}, da der ikke programmæssigt på dette tidspunkt er forskel på de forskellige typer ind og ud-strømme.

Når der i funktionen \texttt{set\_in\_out()} åbnes filer, er der forskel på om der skal læses eller skrives til filen. Åbningen af disse filer gøres ved hjælp af systemkaldet \texttt{open}, der ligesom \texttt{fopen}, åbner en fil. Forskellen på de to, er blandt andet at \texttt{open} returnere et heltal der refererer til en fildeskriptor, i stedet for FILE-typen. Man kan i \texttt{open}-funktionen også fortælle hvad man skal bruge filen til. Fx læse eller skrive. I tilfældet hvor vi åbner en fil for at skrive til den, er vi blevet nødt til at give den et ekstra flag \texttt{S\_IRWXU} som indikerer at den bruger der kører BOSH har adgang til at læse, skrive og udføre filen efterfølgende, da filen ellers blev låst, uden mulighed for brugeren at læse den. Vi beder selvfølgelig kun om de nødvendige tilladelser, så i tilfældet hvor en fil skal læses, beder vi kun om lov til at læse filen.

\subsection{Afslutning}
For at brugeren kan skrive \verb+exit+ i BOSH og dermed afslutte programmet, er en enkelt linie tilføjet til \verb+bosh.c+'s \verb+main()+-funktion. 

Det tjekkes vha. \verb+strcmp+ hvorvidt den givne linie fra brugeren ikke er lig \verb+"exit"+.

Hvis dette er tilfældet sættes \verb+terminate+ til \verb+1+, hvilket indikerer, at BOSH skal afslutte. Herefter printes \verb+"Exiting BOSH."+ og programmet afsluttes. 
\subsection{Luk kommandoer, men ikke BOSH}
For at gøre det muligt at CTRL+C'e sig ud af et givent kørende program anvendes \verb+signal()+ systemkaldet. Ved at kalde \verb+signal(SIGINT, SIG_DFL)+ når en børneproces startes i \verb+start_child()+-funktionen, sættes SIGINT (der sender \verb+interrupt+ til processen) tilbage til standard-opførsel.

Dette er nødvendigt da der i \verb+main()+-funktionen (som vi har fået udleveret) er kaldt \verb+signal(SIGINT, SIG_IGN)+, der beder processen (dvs. forældreprocessen) ignorere \verb+interrupt+, da det er ønsket kun at kunne afbryde brugerens kaldte processer. 

BOSH selv skal ikke afbryde.
