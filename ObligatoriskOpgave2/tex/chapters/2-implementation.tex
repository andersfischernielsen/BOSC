\section{Implementation}

\subsection{Multitrådet sum}
Implementationen af multitrådet summering tager imod et antal af iterationer der skal beregnes over, samt et antal tråde der skal udføre summeringen af kvadratroden af tallene \texttt{1..n} i antallet af iterationer. \\

Arbejdet hver tråd skal udføre er delt ud i 'bidder' af arbejde i form af en \texttt{thread\_data} struct. Denne struct har tre members: \texttt{from}, der indikerer ved hvilken iteration summeringen skal starte, \texttt{to}, der indikerer ved hvilken iteration summeringen skal slutte og \texttt{sum}, der er resultatet af summeringen af intervallet i structen. Der genereres en struct for hver tråd, og disse gemmes herefter i et array.\\

Trådenes arbejde bliver udført vha. \texttt{pthread}-biblioteket. En array af \texttt{pthread\_t}-tråd-ID oprettes, hvor adressen til hver plads i arrayet gives til \texttt{pthread\_create}-funktionen. Herved sættes ID'et for tråden til det aktuelle ID, og der kan herefter afventes at trådene færdiggør deres arbejde ved at anvende \texttt{pthread\_join}-funktionen for hvert element i tråd-ID-arrayet.
\texttt{pthread\_create} gives derudover en pointer til funktionen \texttt{runner}, samt adressen for det næste element i \texttt{thread\_data}-arrayet. 

Summeringen sker ved at funktionen \texttt{runner} modtager en \texttt{void}-pointer, der herefter castes til en \texttt{thread\_data}-pointer.
Herefter summeres tallene fra den modtagne \texttt{thread\_data}-struct's \texttt{from}-værdi til modtagne \texttt{thread\_data}-struct's \texttt{to}-værdi. Der summeres fra \texttt{from+1}, for at undgå at to tråde summerer den samme værdi to gange. For eksempel vil to forskellige tråde derfor summere fra \texttt{1-500} og \texttt{501-1000}.
Summeringen gemmes lokalt i funktionen og skrives herefter ind i den modtagne struct. Dette er gjort af performance-grunde, da det viste sig at skrive direkte ind i en struct medførte at CPU-caches kopieres unødvendigt, hvilket tager unødvendig tid. \\

Til slut itereres der over de nu færdigsummerede \texttt{thread\_data}-structs, og summen fra hver struct lægges sammen. Resultatet returneres og printes herefter. \\ 

\texttt{pthread\_create} opretter en tråd, der udfører en funktion med eventuelle givne parametre. 
Funktionen tager imod en \texttt{pthread\_t}-pointer, der er en pointer til den oprettede tråd, en \texttt{pthread\_attr\_t}-pointer, der i implementationen er sat til \texttt{NULL}, hvilket sætter tråd-parametrene til standard-værdierne, en funktions-pointer til den funktion der skal eksekveres af tråden, og en pointer til det argument funktionen skal tage imod. \\

\texttt{pthread\_join} afventer at en given tråd bliver færdig med eksekvering. 
Funktionen tager imod en \texttt{pthread\_t} pointer, hvilket er en pointer til den tråd der skal afventes, samt en \texttt{void}-pointer, hvis indhold sættes til den eksekverede funktions \texttt{exit()}-parameter.\\

\subsection{Multitrådet FIFO buffer som kædet liste}
\label{list.c}

\subsection{Producer-Consumer med bounded buffer}
Producer/Consumer implementationen er baseret på en buffer implementeret som en kædet liste (se sektion \ref{list.c}: \nameref{list.c}). Idéen er at en række tråde skal kunne oprette/producere elementer, mens en anden række tråde samtidigt skal kunne læse/konsumere disse elementer. Dog må der på et hvilket som helst i programmets kørsel ikke være produceret flere elementer end angivet med et kommandolinjeargument. For at løse dette problem, er der brugt 2 pthread-semaforer, som tæller op og ned, alt efter hvor mange elementer der er i bufferen, eller hvor mange der kan tilføjes til bufferen før den er fuld. Disse to semaforer \texttt{full} og \texttt{empty} er i hovedtrådens main-metode sat op til henholdsvis at have startværdierne 0 og bufferens størrelse. \texttt{full} bruges til at angive antallet af nuværende elementer i bufferen. Hvis denne er 0 og en consumer forsøger at tilgå bufferen, vil denne consumer blive nødt til at vente indtil en producer har tilføjet et element til bufferen. Hvis \texttt{empty} er 0 er bufferen fuld, og producere vil blive nødt til at vente indtil en consumer har fjernet et element.\\

\todo{Tænk over om det kan gøres snedigere og uden disse structs}Producere og consumere får tildelt deres arbejde ved hjælp af to typer structs. Producerens struct indeholder information omkring trådens id, hvor den skal starte med at producere fra, samt hvortil. Consumerens struct indeholder også et id, men derudover kun information omkring hvor mange elementer den skal konsumere før den skal stoppe.

\subsection{Banker's algorithm til håndtering af deadlock}

