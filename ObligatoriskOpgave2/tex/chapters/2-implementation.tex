\section{Implementation}

\subsection{Multitrådet sum}
Implementationen af multitrådet summering tager imod et antal af iterationer der skal beregnes over, samt et antal tråde der skal udføre summeringen af kvadratroden af tallene \texttt{1..n} i antallet af iterationer. \\

Arbejdet hver tråd skal udføre er delt ud i 'bidder' af arbejde i form af en \texttt{thread\_data} struct. Denne struct har tre members: \texttt{from}, der indikerer ved hvilken iteration summeringen skal starte, \texttt{to}, der indikerer ved hvilken iteration summeringen skal slutte og \texttt{sum}, der er resultatet af summeringen af intervallet i structen. Der genereres en struct for hver tråd, og disse gemmes herefter i et array.\\

Trådenes arbejde bliver udført vha. \texttt{pthread}-biblioteket. En array af \texttt{pthread\_t}-tråd-ID oprettes, hvor adressen til hver plads i arrayet gives til \texttt{pthread\_create}-funktionen. Herved sættes ID'et for tråden til det aktuelle ID, og der kan herefter afventes at trådene færdiggør deres arbejde ved at anvende \texttt{pthread\_join}-funktionen for hvert element i tråd-ID-arrayet.
\texttt{pthread\_create} gives derudover en pointer til funktionen \texttt{runner}, samt adressen for det næste element i \texttt{thread\_data}-arrayet. 

Summeringen sker ved at funktionen \texttt{runner} modtager en \texttt{void}-pointer, der herefter castes til en \texttt{thread\_data}-pointer.
Herefter summeres tallene fra den modtagne \texttt{thread\_data}-struct's \texttt{from}-værdi til modtagne \texttt{thread\_data}-struct's \texttt{to}-værdi. Der summeres fra \texttt{from+1}, for at undgå at to tråde summerer den samme værdi to gange. For eksempel vil to forskellige tråde derfor summere fra \texttt{1-500} og \texttt{501-1000}.
Summeringen gemmes lokalt i funktionen og skrives herefter ind i den modtagne struct. Dette er gjort af performance-grunde, da det viste sig at skrive direkte ind i en struct medførte at CPU-caches kopieres unødvendigt, hvilket tager unødvendig tid. \\

Til slut itereres der over de nu færdigsummerede \texttt{thread\_data}-structs, og summen fra hver struct lægges sammen. Resultatet returneres og printes herefter. \\ 

\texttt{pthread\_create} opretter en tråd, der udfører en funktion med eventuelle givne parametre. 
Funktionen tager imod en \texttt{pthread\_t}-pointer, der er en pointer til den oprettede tråd, en \texttt{pthread\_attr\_t}-pointer, der i implementationen er sat til \texttt{NULL}, hvilket sætter tråd-parametrene til standard-værdierne, en funktions-pointer til den funktion der skal eksekveres af tråden, og en pointer til det argument funktionen skal tage imod. \\

\texttt{pthread\_join} afventer at en given tråd bliver færdig med eksekvering. 
Funktionen tager imod en \texttt{pthread\_t} pointer, hvilket er en pointer til den tråd der skal afventes, samt en \texttt{void}-pointer, hvis indhold sættes til den eksekverede funktions \texttt{exit()}-parameter.\\

\subsection{Multitrådet FIFO buffer som kædet liste}
\label{list.c}
For at færdiggøre funktionaliteten af FIFO listen, er metoderne \texttt{Add(List *l, Node *n)} og \texttt{Remove(List *l, Node *n)} implementeret;

\subsubsection{Add Function}
Denne funktion tilføjer \texttt{Node *n} til \texttt{List *l}. Når funktionen kaldes bliver \texttt{next} member af den nuværende \texttt{last} node sat til at være \texttt{*n}. Derefter bliver listens \texttt{last} member sat til at være \texttt{*n}. Til sidst er \texttt{len} forøget med 1.

\subsubsection{Remove Function}

This function removes Node *n from the list *l. When the function is called, the pointer to first node of the list is saved to a local variable. Note that the \texttt{first} member of the list is actually not the first node but a root element and therefore \texttt{first->next} is the first node. Now we set the \texttt{next} member removed node to be the first element. The \texttt{len} member of the list is decremented and if the list is empty we set the \texttt{last} member to point to the \texttt{first} member.\\

By using this structure we ensure that we have a FIFO linked list that allows us to add as many nodes as we want as long as there is enough memory available on the OS.

\subsubsection{Multithread Support}
To add support for mutliple threads mutexes are used. Each \texttt{list} has an added member \texttt{lock} which is of type \texttt{pthread\_mutex\_t}. When the list is created the mutex is initialised. Then in the \texttt{add} and \texttt{remove} functions, the \texttt{lock} member of the list is locked and in the end of the function the lock is unlocked again. That way \texttt{list.c} provides adding and removing from multiple lists at the same time by multiple threads, without running into race conditions.

\subsection{Producer-Consumer med bounded buffer}
Producer/Consumer implementationen er baseret på en buffer implementeret som en kædet liste (se sektion \ref{list.c}: \nameref{list.c}). Idéen er at en række tråde skal kunne oprette/producere elementer, mens en anden række tråde samtidigt skal kunne læse/konsumere disse elementer. Dog må der på et hvilket som helst i programmets kørsel ikke være produceret flere elementer end angivet med et kommandolinjeargument. For at løse dette problem, er der brugt 2 pthread-semaforer, som tæller op og ned, alt efter hvor mange elementer der er i bufferen, eller hvor mange der kan tilføjes til bufferen før den er fuld. Disse to semaforer \texttt{full} og \texttt{empty} er i hovedtrådens main-metode sat op til henholdsvis at have startværdierne 0 og bufferens størrelse. \texttt{full} bruges til at angive antallet af nuværende elementer i bufferen. Hvis denne er 0 og en consumer forsøger at tilgå bufferen, vil denne consumer blive nødt til at vente indtil en producer har tilføjet et element til bufferen. Hvis \texttt{empty} er 0 er bufferen fuld, og producere vil blive nødt til at vente indtil en consumer har fjernet et element.\\

\todo{Tænk over om det kan gøres snedigere og uden disse structs}Producere og consumere får tildelt deres arbejde ved hjælp af to typer structs. Producerens struct indeholder information omkring trådens id, hvor den skal starte med at producere fra, samt hvortil. Consumerens struct indeholder også et id, men derudover kun information omkring hvor mange elementer den skal konsumere før den skal stoppe.

\subsection{Banker's algorithm til håndtering af deadlock}


